# part III - Генераторы и Итераторы

```python
def count_down_1(num):
    result = []
    while num != 0:
        result.append(num - 1)
        num -= 1
    return result

print(count_down_1(5))                          # [4, 3, 2, 1, 0]
```
Храним промежуточные результаты работы функции в списке. Плюс, пока выполняется генерация мы будем находиться в функции
и покинем её только после выполнения оператора `return`. Что здесь важно? 
1. расход памяти. Нам надо где-то хранить список, а он может быть большим.
2. в каждый момент времени нам необходимо только одно значение из этого списка. Остальное просто лежит в памяти.
3. мы находимся в функции пока не сгенерируются все значения списка. 

```python
def count_down_2(num):
    while num != 0:
        yield num - 1
        num -= 1

it = count_down_2(5)
print(next(it))                                 # 4
print(next(it))                                 # 3
print(next(it))                                 # 2
print(next(it))                                 # 1
print(next(it))                                 # 0
# print(next(it))                               # ERROR
```

1. не расходуем память для хранения промежуточных результатов работы генератора.
2. при каждом обращении к генератору мы получаем только одно значение.
3. после получения значения мы возвращаемся в место вызова генератора.
4. получаем ровно столько, сколько нам нужно.

```python
def count_down_2(num):
    while num != 0:
        yield num - 1
        num -= 1

for i in count_down_2(5):
    print(i)
```