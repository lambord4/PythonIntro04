# Работа с файлами

## Пути к файлам

Для того чтоб прочитать файл, для начала его надо открыть, а для этого необходимо указать путь к этому файлу. Путь к 
файлу - это строка, которая представляет местоположение файла. Он состоит из имени диска, имени (или имён) папки(ок) и,
собственно, имени файла. Все эти компоненты пути, разделены файловыми сепараторами, в роли которых выступает символ
косой черты (или, по научному, slash). В разных ОС используются разные сепараторы: в `Windows` используется обратный -
`\ ` слэш, а `Linux`, `Unix`, `MacOSX` используют прямой слэш - `/`.

В Python можно узнать какой используется сепаратор если запустить следующий код

```python
import os
print(os.sep)                                   # /      Это в ОС - MacOSX
```

```
/
└── Folder_1
        └── Folder_2
                └── Folder_3
                        └── File_3_1.txt
                        └── File_3_2.gif
```

полный путь (от корня диска до файлов в папке `Folder_3`) будет выглятеть следующим образом

```
/Folder_1/Folder_2/Folder_3/File3_1.txt   
/Folder_1/Folder_2/Folder_3/File3_2.gif
```

Каждая папка, по умолчанию, содержит два специальных файловых объекта (или папки), которые создаются автоматически при 
создании любой папки:

```
/
└── .
└── ..
└── Folder_1
        └── .
        └── ..
        └── File_1_1.mov
        └── Folder_2
                └── .
                └── ..
                └── Folder_3
                        └── .
                        └── ..
                        └── File_3_1.txt
                        └── File_3_2.gif
```

Обычно это скрытые папки, но каждая из них имеет собственное назначение.
Папка с именем `.` является ссылкой на туже папку в которой она находится. Например, папка `.` в папке `Folder_2` 
ссылается на эту же папку.
Папка с именем `..` является ссылкой на папку-родитель. Например, папка `..` в папке `Folder_3` ссылается на папку
`Folder_2`.  
Папку `..` можно использовать, чтоб перемещаться по дерему папок вверх, к корню файловой системы. Например, если мы 
находимся в папке `Folder_3` и нам надо добраться до файла `File_1_1.mov`, мы може написать следующий путь:

`../../File_1_1.mov`

## Концы строк в файлах (касается файлов в текстовом формате)

Проблема, с которой часто приходится сталкиваются при переносе файлов между разными ОС - представление новой строки или 
окончания строки. Применение концов строк пришло из азбуки Морзе. При передаче текста надо было как, то обозначать конец
передачи одной строки, чтоб было понятно где начало другой строки. Для этого использовались специальные символы.  
Здесь, так же. Есть специальные, не печатаемые (не имеющие графического начертания) символы, определюющие конец строки в
текстовом файле. Но в разных ОС этот символ(ы) разный.  
Этот символ был стандартизирован для телетайпов как Международной организацией по стандартизации (ISO), так и 
Американской ассоциацией стандартов (ASA). Стандарт ASA гласит, что в конце строки должна использоваться 
последовательность символов возврата каретки (`CR` или `\r`) и перевода строки (`LF` или `\n`) (`CR+LF` или `\r\n`). 
Однако в стандарте `ISO` допускаются либо `CR+LF` символы, либо только `LF` символы.  
И опять, в Windows использует `CR+LF` символы для обозначения новой строки, а в `Unix/Linux` и более новые версии `Mac` 
используют только `LF` символ. Это может вызвать некоторые сложности при обработке файлов в операционной системе, 
отличной от источника файла. Вот пример файла записанного в Windows:

```
Максимальное напряжение, B              250\r\n
Максимальный ток, А                     6\r\n
Тип рабочего тока                       переменный\r\n
Высота педали, мм                       43.5\r\n
Толщина педали, мм                      18\r\n
Количество контактов (без реверса)      6\r\n
```

а вот так он будет интерпретирован в `Unix` системе:

```
Максимальное напряжение, B              250\r
\n
Максимальный ток, А                     6\r
\n
Тип рабочего тока                       переменный\r
\n
Высота педали, мм                       43.5\r
\n
Толщина педали, мм                      18\r
\n
Количество контактов (без реверса)      6\r
\n
```

Это может вызывать затруднения при работе стакими файлами. Многие, пробвинутые, текстовые редакторы имеют опции 
позволяющие выставлять определённые символы конца строк, независимо от ОС, а так же выполнять конвертацию одних символов
в другие.

## Кодировки символов
Другая распространенная проблема, с которой вы можете столкнуться, - это кодировка символов в файле или просто, 
кодировка файла. Кодировка - это перевод байтовых данных в читаемые человеком символы. Каждому символу присваевается 
числове значение для представления этого символа. Двумя наиболее распространенными кодировками являются 
[`ASCII`](https://ru.wikipedia.org/wiki/ASCII) и [`UNICODE`](https://ru.wikipedia.org/wiki/Юникод). `ASCII` может 
хранить [только 128 символов](https://www.ascii-code.com/) , в то время как `Unicode` может содержать 
[более 1 миллиона символов](https://unicode-table.com).  
ASCII на самом деле является подмножеством `Unicode` (`UTF-8`), что означает, что `ASCII` и `Unicode` имеют одинаковые 
числовые и символьные значения. Важно отметить, что анализ файла с неправильной кодировкой символов может привести к 
сбоям или искажению символа. Например, если файл был создан с использованием кодировки `UTF-8`, и вы пытаетесь 
проанализировать его с помощью кодировки `ASCII`, если есть символ, который находится за пределами этих 128 значений, 
то будет выдано сообщение об ошибке. 

## Как открыть и закрыть файл?

Прежде чем что-то читать из файла Или что-то туда писать, файл, необходимо открыть. А после завершения обмена данными с 
файлом, его необходимо закрыть.  
Открыть файл, в Python, очень просто. Достаточно вызвать встроенную функцию 
[`open()`](https://docs.python.org/3/library/functions.html#open), передать необходимые параметры и в результате 
получить [файловый объект](https://docs.python.org/3/glossary.html#term-file-object), через который и будем 
взаимодействовать с содержимым файла.   

```python
file = open('example_file.txt')
```

Переменная `file` и есть тем самым объектом файла. Закрывается файл, ещё проще. Достаточно вызвать функцию `close()` у 
файлового объекта.

```python
file = open('example_file.txt')

file.close()
```
После этого действия, файл считается закрытым.

> **ВНИМАНИЕ:** Файл необходимо, всегда, закрывать после завершения работы с ним! В большинстве случаев, после 
завершения работы программы или скрипта, файл будет закрыт автоматически, но это не гарантирует когда именно это 
произойдёт. Это может привести к утрате данных или к повреждению файла, после чего с ним будет невозможно большоое
> работать.

При работе с файлом, пожно "словить" исключение. Например `FileNotFoundError`. Поэтому, работу с файлом, не плохо 
производить в блоке `try - except`

```python
file = ''
try:
    file = open('example_file.txt')
    
    
except FileNotFoundError as ex:
    print('Файл не найден!', ex)
finally:
    if not file.closed:
        file.close()
```

Имя файла, является обязательным параметром функции `open()`. То есть, его надо указывать всегда. Второй параметр, не 
менее важный, но не обязятельный, определяет режим открытия файла

```
+===========+=================================================================+
| Character |                             Meaning                             |
+===========+=================================================================+
| 'r'       | open for reading (default)                                      |
+-----------+-----------------------------------------------------------------+
| 'w'       | open for writing, truncating the file first                     |
+-----------+-----------------------------------------------------------------+
| 'x'       | open for exclusive creation, failing if the file already exists |
+-----------+-----------------------------------------------------------------+
| 'a'       | open for writing, appending to the end of the file if it exists |
+-----------+-----------------------------------------------------------------+
| 'b'       | binary mode                                                     |
+-----------+-----------------------------------------------------------------+
| 't'       | text mode (default)                                             |
+-----------+-----------------------------------------------------------------+
| '+'       | open a disk file for updating (reading and writing)             |
+-----------+-----------------------------------------------------------------+
```

## Позиционирование

Для позиционирования по файлу можно использовать функции: `seek()` - изменение позиции файлового указателя и `tell()` - 
определение текущей позиции файлового указателя.

### seek()
Данная функция может принимать два параметра 

```
seek(offset, whence=SEEK_SET)
```

`offset` - смещение, выраженное в байтах, относительно позиции заданной параметром `whence`. Значения (и описание) 
которые может принимать параметр `whence` описаны ниже

```
+----------------+------------------------------------------------------------------------------+
| SEEK_SET или 0 | начало файла (по умолчанию); смещение должно быть нулевым или положительным  |
+----------------+------------------------------------------------------------------------------+
| SEEK_CUR или 1 | текущая позиция в файле; смещение может быть положительным и отрицательным   |
+----------------+------------------------------------------------------------------------------+
| SEEK_END или 2 | конец файла; смещение обычно отрицательное                                   |
+----------------+------------------------------------------------------------------------------+
```

Значениия `SEEK_*` можно получить из модуля `os`

```python
import os

print(os.SEEK_SET)                              # 0
print(os.SEEK_CUR)                              # 1
print(os.SEEK_END)                              # 2
```

При работе с текстовыми файлами, значения параметра `whence` могут быть только `SEEK_SET` или `SEEK_END` и, параметр
`SEEK_END` можно использовать только со смещением равным нулю.  
Для файлов открытых в бинарном режиме, доступны все значения параметра `whence` со смещением описаным в таблице выше.

Например, чтоб прочитать из файла только первую и последнюю строки надо сделать так:

```python
from pprint import pprint as pp
from os import SEEK_SET, SEEK_END

lst = [
    'Максимальное напряжение, B              250',
    'Максимальный ток, А                     6',
    'Тип рабочего тока                       переменный',
    'Высота педали, мм                       43.5',
    'Толщина педали, мм                      18',
    'Количество контактов (без реверса)      6'
]

with open('example_file.txt', 'w') as file:
    for line in lst:
        file.write(line)
        file.write('\n')
        
lst = []
with open('example_file.txt') as file:
    lst.append(file.readline())                 # считываем первую строку из файла
    file.seek(0, SEEK_END)                      # смещаем указатель в конец файла
    print('count of byte:', file.tell(), '\n') 
    file.seek(file.tell() - 71, SEEK_SET)       # смещаем указатель относительно начала файла в 
                                                # позицию 'конец файла' - 71 байт
    lst.append(file.readline())                 # считываем последнюю строку

pp(lst)
```

```python
from os import SEEK_SET, path

filename = 'data.txt'
with open(filename, 'w') as f:
    f.write("Hello World!\nHow are you today?\nThank you!")

print('File size:', path.getsize(filename))

with open(filename, 'r+') as f:                 # открываем файл в режиме чтение/запись
    f.readline()                                # считываем первую строку
    start = f.tell()                            # определяем (и запоминаем) позицию начала второй строки

    f.readline()                                # считываем вторую строку

    last_line = f.readline()                    # считываем и запоминаем третью строку

    f.seek(start, SEEK_SET)                     # устанавливаем файловый указатель в позицию начала второй строки 
    f.write('What do you do?\n')                # перезаписываем вторую строку новой строкой
    f.write(last_line)                          # перезаписываем третью строку
    f.truncate()                                # стираем всё что осталось после третьей строки
    f.seek(0, SEEK_SET)                         # перемещаемфайловый указатель в начало файла
    print(f.read())                             # считываем всё содержимое что получилось
```

Так же можно позиционироваться и в бинарном файле, главное его открыть в режиме `b`.

## Примеры

```python
from pprint import pprint as pp

lst = [
    'Максимальное напряжение, B              250',
    'Максимальный ток, А                     6',
    'Тип рабочего тока                       переменный',
    'Высота педали, мм                       43.5',
    'Толщина педали, мм                      18',
    'Количество контактов (без реверса)      6'
]

pp(lst)

file = open('example_file.txt', 'w')
for line in lst:
    file.write(line)
    file.write('\n')

file.close()
print()

# read all
print()
lst = []
file = open('example_file.txt')
lst = file.read()
file.close()
pp(lst)
print()

# read all
print()
lst = []
file = open('example_file.txt')
lst = file.readlines()
file.close()
pp(list(map(lambda x: x.strip('\n'), lst)))
print()

# read by 40 symbols
lst = []
pp(lst)
file = open('example_file.txt')
while True:
    line = file.readline(40)
    if line != '':
        lst.append(line.strip('\n'))
    else:
        break
file.close()
print()
pp(lst)

# read by line
lst = []
pp(lst)
file = open('example_file.txt')
for line in file.readlines():
    lst.append(line.strip('\n'))
file.close()
print()
pp(lst)

# read by line
lst = []
pp(lst)
file = open('example_file.txt')
for line in file:
    lst.append(line.strip('\n'))
file.close()
print()
pp(lst)
```

```python
size_buff = 32
src = open('dog_1.jpg', 'rb')
dst = open('dog_2.jpg', 'wb')

while True:
    data = src.read(size_buff)
    if data:
        dst.write(data)
    else:
        break

src.close()
dst.close()
```













