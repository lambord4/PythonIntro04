# Dict

## Определение словаря
Словари - это реализация Python структуры данных, более известная как ассоциативный массив. Словарь состоит из набора 
пар ключ-значение. Каждая пара ключ-значение отображает ключ на соответствующее значение.

Вы можете определить словарь, заключив разделенный запятыми список пар ключ-значение в фигурные скобки `{}`. 
Двоеточие `:` отделяет каждый ключ от его связанного значения:
```
d  =  { 
    < ключ > :  < значение > , 
    < ключ > :  < значение > , 
      . 
      , 
      , 
    < ключ > :  < значение > 
}
```
Следующее определяет словарь, который сопоставляет местоположение с названием соответствующей бейсбольной команды 
Высшей лиги:
```python
MLB_team  =  {
    'Colorado': 'Rockies', 
    'Boston': 'Red Sox', 
    'Minnesota': 'Twins', 
    'Milwaukee': 'Brewers', 
    'Seattle': 'Mariners' 
}
```

![MLB_Team](img/MLB_Team.png)

Также создать словарь можно используя встроенный метод `dict()`. Аргумент `dict()` должен быть последовательностью
пар ключ-значение. Для этого хорошо подходит список кортежей:

```
d = dict([ 
    (<ключ>, <значение>), 
    (<ключ>, <значение>), 
      . 
      . 
      . 
    (<ключ>, <значение>) 
])
```

MLB_team тогда также можно определить так:

```python
MLB_team = dict([
    ('Colorado', 'Rockies'), 
    ('Boston', 'Red Sox'), 
    ('Minnesota', 'Twins'), 
    ('Milwaukee', 'Brewers'), 
    ('Seattle', 'Mariners')  
])
```

Если значения ключа являются простыми строками, они могут быть указаны в качестве аргументов ключевых слов. Итак, вот 
еще один способ определить MLB_team:

```python
MLB_team = dict(
    Colorado = 'Rockies', 
    Boston = 'Red Sox', 
    Minnesota = 'Twins', 
    Milwaukee = 'Brewers', 
    Seattle = 'Mariners'  
)
```

После того как вы определили словарь, вы можете отобразить его содержимое так же, как вы можете сделать для списка. Все
три приведенных выше определения выглядят следующим образом:

```python
MLB_team = { ... }
print(type(MLB_team))                           # <class 'dict'>
print(MLB_team)                                 # {'Colorado': 'Rockies', 'Boston': 'Red Sox', 'Minnesota': 'Twins', 
                                                # 'Milwaukee': 'Brewers', 'Seattle': 'Mariners'}
```

Записи в словаре отображаются в порядке их определения. Но это не имеет значения, когда дело доходит до их извлечения.
Элементы словаря не доступны по числовому индексу:

```
print(MLB_team[1])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(MLB_team[1])
KeyError: 1
```

## Доступ к значениям словаря
Конечно, словарные элементы должны быть как-то доступны. Если вы не получите их по индексу, то как вы их получите?
Значение извлекается из словаря путем указания соответствующего ключа в квадратных скобках `[]`:

```python
print(MLB_team['Minnesota'])                    # Twins
print(MLB_team['Colorado'])                     # Rockies
```

Если вы ссылаетесь на ключ, которого нет в словаре, Python вызывает исключение:

```
print(MLB_team['Toronto'])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(MLB_team['Toronto'])
KeyError: 'Toronto'
```

Добавление записи в существующий словарь - это просто вопрос назначения нового ключа и значения:

```python
MLB_team['Kansas City'] = 'Royals'
print(MLB_team)                                 # {'Colorado': 'Rockies', 'Boston': 'Red Sox', 'Minnesota': 'Twins', 
                                                # 'Milwaukee': 'Brewers', 'Seattle': 'Mariners', 
                                                # 'Kansas City': 'Royals'}
```

Если вы хотите обновить запись, вы можете просто присвоить новое значение существующему ключу:


```python
MLB_team['Seattle'] = 'Seahawks'
print(MLB_team)                                 # {'Colorado': 'Rockies', 'Boston': 'Red Sox', 'Minnesota': 'Twins', 
                                                # 'Milwaukee': 'Brewers', 'Seattle': 'Seahawks', 
                                                # 'Kansas City': 'Royals'}
```

Чтобы удалить запись, используйте delоператор, указав ключ для удаления:

```python
del  MLB_team['Seattle']
print(MLB_team)                                 # {'Colorado': 'Rockies', 'Boston': 'Red Sox', 'Minnesota': 'Twins', 
                                                # 'Milwaukee': 'Brewers', 'Kansas City': 'Royals'}
```

## Ключи словаря и индексы списков
Возможно, вы заметили, что интерпретатор вызывает то же исключение, KeyError когда к словарю обращаются либо с 
неопределенным ключом, либо с помощью числового индекса:

```
print(MLB_team['Toronto'])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(MLB_team['Toronto'])
KeyError: 'Toronto'

print(MLB_team[1])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(MLB_team[1])
KeyError: 1
```

На самом деле это та же ошибка. В последнем случае [1]выглядит как числовой индекс, но это не так.
Позже в этом руководстве вы увидите, что объект любого неизменяемого типа может использоваться в качестве словарного 
ключа. Соответственно, нет причин, по которым вы не можете использовать целые числа:

```python
d = { 0: 'a', 1: 'b', 2: 'c', 3: 'd' }
print(d)                                        # {0: 'a', 1: 'b', 2: 'c', 3: 'd'}
print(d[0])                                     # a
print(d[2])                                     # c
```

В выражениях `MLB_team[1]`, `d[0]`и `d[2]`, числа в квадратных скобках выглядят так, как будто они могут быть индексами.
Но они не имеют ничего общего с порядком элементов в словаре. Python интерпретирует их как словарные ключи. Если вы 
определите этот же словарь в обратном порядке, вы все равно получите те же значения, используя те же ключи:

```python
d = { 3: 'd', 2: 'c', 1: 'b', 0: 'a' } 
print(d)                                        # {3: 'd', 2: 'c', 1: ' b ', 0:' a '}
print(d[0])                                     # a
print(d[2])                                     # c
```

Синтаксис может выглядеть похожим, но вы не можете рассматривать словарь как список:

```
print(type(d))                                  # <class 'dict'>
print(d[-1])

Traceback (most recent call last):
  File "<input>", line 1, in <module>
    d[-1]
KeyError: -1

print(d[0: 2])

Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(d[0: 2])
TypeError: unhashable type: 'slice'

d.append('e')

Traceback (most recent call last):
  File "<input>", line 1, in <module>
    d.append('e')
AttributeError: 'dict' object has no attribute 'append'
```

> Примечание. Хотя доступ к элементам в словаре не зависит от порядка, Python гарантирует, что порядок элементов в 
словаре сохраняется. При отображении элементы будут отображаться в том порядке, в котором они были определены, и 
итерация по клавишам также будет происходить в этом порядке. Элементы, добавленные в словарь, добавляются в конце. 
Если элементы удалены, порядок оставшихся элементов сохраняется.
Вы можете рассчитывать только на это сохранение порядка совсем недавно. Он был добавлен как часть спецификации языка 
Python в версии 3.7 . Тем не менее, это было верно и для версии 3.6 - по случайности в результате реализации, но не 
>гарантируется спецификацией языка.

## Постепенное создание словаря
Создание словаря с использованием фигурных скобок и списка пар ключ-значение, как показано выше, хорошо, если вы 
заранее знаете все ключи и значения. Но что, если нужно создать словарь на лету?

Вы можете начать с создания пустого словаря, который задается пустыми фигурными скобками. Затем вы можете добавлять 
новые пары ключ-значения по одному:

```python
person = {}
print(type(person))                             # <class 'dict'>
person['fname'] = 'Joe'
person['lname'] = 'Fonebone'
person['age'] = 51
person['spouse'] = 'Edna'
person['children'] = ['Ralph', 'Betty', 'Joey']
person['pets'] = {'dog': 'Fido', 'cat': 'Sox'}
print(person)                                   # {
                                                #       'fname': 'Joe', 
                                                #       'lname': 'Fonebone', 
                                                #       'age': 51, 
                                                #       'spouse': 'Edna', 
                                                #       'children': [
                                                #           'Ralph',
                                                #           'Betty', 
                                                #           'Joey'
                                                #       ], 
                                                #       'pets': {
                                                #           'dog': 'Fido', 
                                                #           'cat': 'Sox'
                                                #       }
                                                # }
```

Как только словарь создан таким образом, к его значениям обращаются так же, как и к любому другому словарю:

```python
print(person['fname'])                          # Joe
print(person['age'])                            # 51
print(person['children'])                       # ['Ralph', 'Betty', 'Joey']
```

Для извлечения значений в под-списке или под-категории требуется дополнительный индекс или ключ:

```python
print(person['children'][-1])                   # Joey
print(person['pets']['cat'])                    # Sox
```

Этот пример демонстрирует другую особенность словарей: значения, содержащиеся в словаре, не обязательно должны быть 
одного типа. Например в словаре `person`, некоторые значения являются строками, одно значение - целое число, 
одно - список и одно - словарь.

Так же как и значения в словаре не обязательно должны быть одного типа, ключи также могут быть разного типа:

```python
foo = { 42: 'aaa', 2.78: 'bbb', True: 'ccc' }
print(foo)                                      # {42: 'aaa', 2.78: 'bbb', True: 'ccc'}
print(foo[42])                                  # aaa
print(foo[2.78])                                # bbb
print(foo[True])                                # ccc
```

Здесь один из ключей - целое число, один - число с плавающей запятой, а другой - логическое значение. Не очевидно, как 
это было бы полезно, но вы никогда не знаете.

Обратите внимание, насколько универсальны словари Python. В MLB_teamодном и том же фрагменте информации (название 
бейсбольной команды) хранится для каждого из нескольких географических местоположений. personс другой стороны, хранит 
различные типы данных для одного человека.

Вы можете использовать словари для самых разных целей, потому что существует очень мало ограничений на допустимые ключи
и значения. Но есть некоторые. Читать дальше!

## Ограничения на ключи словарей
Почти любой тип значения может быть использован в качестве словарного ключа в Python. Вы только что видели этот пример,
где объекты integer, float и Boolean используются в качестве ключей:

```python
foo = {42: 'aaa', 2.78: 'bbb', True: 'ccc'}
print(foo)                                      # {42: 'aaa', 2.78: 'bbb', True: 'ccc'}
```

Вы даже можете использовать встроенные объекты, такие как типы и функции:

```python
d = {int: 1, float: 2, bool: 3}
print(d)                                        # {<class 'int'>: 1, <class 'float'>: 2, <class 'bool'>: 3}
print(d[float])                                 # 2

d = {bin: 1, hex: 2, oct: 3}
print(d)                                        # {
                                                #       <built-in function bin>: 1,
                                                #       <built-in function hex>: 2,
                                                #       <built-in function oct>: 3
                                                # }
print(d[oct])                                   # 3
```

Однако есть несколько ограничений, которым нужно следовать при определении ключей словаря.
Во-первых, данный ключ может появиться в словаре только один раз. Дублирование ключей не допускается. Словарь 
сопоставляет каждый ключ с соответствующим значением, поэтому нет смысла отображать конкретный ключ более одного раза.
Вы видели выше, что когда вы присваиваете значение уже существующему ключу словаря, он не добавляет ключ во второй раз,
а заменяет существующее значение:

```python
MLB_team  =  {
        'Colorado': 'Rockies',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners'
}

print(MLB_team['Minnesota'])                    # Twins
MLB_team['Minnesota'] = 'Timberwolves'
print(MLB_team['Minnesota'])                    # Timberwolves
```

Точно так же, если вы укажете ключ во второй раз во время первоначального создания словаря, второе вхождение 
переопределит первое:

```python
MLB_team  =  {
        'Colorado': 'Rockies',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners',
        'Minnesota': 'Timberwolves'
}

print(MLB_team)                                 # {
                                                #       'Colorado': 'Rockies', 
                                                #       'Boston': 'Red Sox', 
                                                #       'Minnesota': 'Timberwolves', 
                                                #       'Milwaukee': 'Brewers', 
                                                #       'Seattle': 'Mariners'
                                                # }
```

Во-вторых, ключ словаря должен быть неизменным. Вы уже видели примеры, когда некоторые из неизменяемых типов, с 
которыми вы знакомы - integer, float, string и Boolean - служили в качестве ключей словаря.
Кортеж также может быть ключом словаря, потому что кортежи являются неизменяемыми:

```python
d = {(1, 1): 'a', (1, 2): 'b', (2, 1): 'c', (2, 2): 'd'}
print(d[(1, 1)])                                # a
print(d[(2, 1)])                                # c
```

Вспомните из обсуждения [кортежей](../lesson_05/04%20-%20tuple.md), что одним из оснований для использования 
кортежа вместо списка является то, что существуют обстоятельства, когда требуется неизменный тип. Это один из них.

Однако ни список, ни другой словарь не могут служить ключом словаря, поскольку списки и словари являются 
изменяемыми:

```
d = {[1, 1]: "a", [1, 2]: "b", [2, 1]: "c", [2, 2]: "d"}
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    d = {[1, 1]: "a", [1, 2]: "b", [2, 1]: "c", [2, 2]: "d"}
TypeError: unhashable type: 'list'
```

> ### Техническое примечание.
> Почему в сообщении об ошибке указано «unhashable»?
Технически, не совсем правильно говорить, что объект должен быть неизменным для использования в качестве словарного 
ключа. Точнее говоря, объект должен быть хэшируемым , что означает, что он может быть передан хеш-функции. Хеш-функция 
берет данные произвольного размера и отображает их в относительно более простое значение фиксированного размера, 
называемое хеш-значением (или просто хеш), которое используется для поиска и сравнения таблиц.
Встроенная hash()функция Python возвращает значение хеш-функции для объекта, который можно хэшировать, и вызывает 
> исключение для объекта, который не является:
```
hash('foo')
1672058079424933597
>>> hash([1, 2, 3,])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    hash([1, 2, 3,])
TypeError: unhashable type: 'list'
```
> Все встроенные неизменяемые типы, о которых вы узнали до сих пор, являются хэшируемыми, а типы изменяемых контейнеров
(списки и словари) - нет. Таким образом, для настоящих целей вы можете думать о hashable и неизменяемом как о более или
менее синонимичном.
> В будущих уроках встретим изменяемые объекты, которые также можно хэшировать.

## Ограничения на значения словаря
В отличие от этого, нет никаких ограничений на значения словаря. Буквально нет вообще. Значением словаря может быть 
любой тип объектов, поддерживаемых Python, включая изменяемые типы, такие как списки и словари, а также определяемые 
пользователем объекты, о которых вы узнаете в следующих уроках.
Также нет ограничений на то, что определенное значение появляется в словаре несколько раз:

```python
d = {0: 'a', 1: 'a', 2: 'a', 3: 'a'}
print(d)                                        # {0: 'a', 1: 'a', 2: 'a', 3: 'a'}
print(d[0] == d[1] == d[2])                     # True
```

## Операторы и встроенные функции
Вы уже познакомились со многими операторами и встроенными функциями, которые можно использовать со [строками]() , 
[списками]() и [кортежами](). Некоторые из них также работают со словарями.
Например, операторы `in`, `and`, `not in` возвращают `True` или `False` в зависимости от того, встречается ли указанный
операнд в качестве ключа в словаре:

```python
MLB_team  =  {
        'Colorado': 'Rockies',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners',
        'Minnesota': 'Timberwolves'
}

print('Milwaukee' in MLB_team)                  # True
print('Toronto' in MLB_team)                    # False
print('Toronto' not in MLB_team)                # True
```

Вы можете использовать `in` для проверки наличия ключа в словаре, чтобы избежать появления ошибки при попытке доступа к 
ключу, которого нет в словаре:

```
print(MLB_team['Toronto'])
Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(MLB_team['Toronto'])
KeyError: 'Toronto'
print('Toronto' in MLB_team and MLB_team['Toronto'])    # False
```

Во втором случае из-за оценки короткого замыкания выражение MLB_team['Toronto']не оценивается, поэтому `KeyError`
исключение не происходит.

`len()` - функция возвращает количество пар ключ-значение в словаре:

```python
MLB_team  =  {
        'Colorado': 'Rockies',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners',
        'Minnesota': 'Timberwolves'
}

print(len(MLB_team))                            # 5
```

## Встроенные словарные методы
Как и в случае со строками и списками, есть несколько встроенных методов, которые можно вызывать в словарях. На самом 
деле, в некоторых случаях методы списка и словаря имеют одно и то же имя. (В обсуждении объектно-ориентированного 
программирования вы увидите, что для разных типов вполне допустимо иметь методы с одинаковыми именами.)
Ниже приведен обзор методов, которые применяются к словарям:

- **d.clear()**

> Очищает словарь.

`d.clear()` удаляет из словаря `d` все пары ключ-значение:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}

d.clear()
print(d)                                        # {}
```

- **d.get(<key>[, <default_value>])**

> Возвращает значение ключа, если оно существует в словаре.

Метод словаря Python `get()` предоставляет удобный способ получения значения ключа из словаря без предварительной 
проверки наличия ключа и без возникновения ошибки.
`d.get(<key>)` выполеняет поиск ключа `<key>` в словаре `d` и возвращает соответствующее значение, если он найден. Если
`<key>` не найден, возвращается `None`:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(d.get('b'))                               # 20
print(d.get('z'))                               # None
```

Если `<key>` не найден и задан необязательный парамер `<default>`, возвращается значение этого параметра вместо `None`:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d.get('z', -1))                           # -1
```

- **d.items()**

> Возвращает список пар ключ-значение в словаре.

`d.items()` возвращает список кортежей, содержащих пары ключ-значение в `d`. Первый элемент в каждом 
кортеже - это ключ, а второй элемент - это значение ключа:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(list(d.items()))                          # [('a', 10), ('b', 20), ('c', 30)]
print(list(d.items())[1][0])                    # 'b'
print(list(d.items())[1][1])                    # 20
```

- **d.keys()**

> Возвращает список ключей в словаре.

`d.keys()` возвращает список всех ключей в `d`:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(list(d.keys()))                           # ['a', 'b', 'c']
```

- **d.values()**

> Возвращает список значений в словаре.

`d.values()` возвращает список всех значений в `d`:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(list(d.values()))                         # [10, 20, 30]
```

Любые повторяющиеся значения в `d` будут возвращены столько раз, сколько они встречаются:

```python
d = {'a': 10, 'b': 10, 'c': 10}
print(d)                                        # {'a': 10, 'b': 10, 'c': 10}
print(list(d.values()))                         # [10, 10, 10]
```

- **d.pop(<key>[, <default>])**

> Удаляет ключ из словаря, если он присутствует, и возвращает его значение.

Если `<key>` присутствует в `d`, `d.pop(<key>)` удаляет `<key>` и возвращает соответствующее значение:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(d.pop('b'))                               # 20
print(d)                                        # {'a': 10, 'c': 30}
```

`d.pop(<key>)` вызывает `KeyError` исключение, если `<key>` отсутствует в `d`:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(d.pop('z'))

Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(d.pop('z'))
KeyError: 'z'
```

Если указать необязательный параметр `<default>`, то в случае отсутствия `<key>` в словаре `d` исключение возбуждаться 
не будет и будет возвращено указаное, дефолтное значение:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(d.pop('z', -1))                           # -1
```

- **d.popitem()**

> Удаляет пару ключ-значение из словаря.

`d.popitem()` удаляет случайную произвольную пару ключ-значение из словаря `d` и возвращает ее в виде кортежа:

```python
d = {'a': 10, 'b': 20, 'c': 30}
print(d)                                        # {'a': 10, 'b': 20, 'c': 30}
print(d.popitem())                              # ('c', 30)
print(d.popitem())                              # ('b', 20)
print(d)                                        # {'a': 10}
```

Если словарь пустой, `d.popitem()` вызовет исключение `KeyError`:

```python
d = {}
print(d)                                        # {}
print(d.popitem())

Traceback (most recent call last):
  File "<input>", line 1, in <module>
    print(d.popitem())
KeyError: 'popitem(): dictionary is empty'
```

- **d.update(<obj>)**

> Объединяет словарь с другим словарем или с итерацией пар ключ-значение.

Если `<obj>` это словарь, `d.update(<obj>)` объединяет записи из `<obj>` и `d`. Для каждого ключа `<obj>`:
- Если ключ отсутствует в `d`, из `<obj>` добавляется пара ключ-значение в `d`.
- Если ключ уже присутствует в `d`, соответствующее значение в `d` для этого ключа обновляется до значения из `<obj>`.

Вот пример, показывающий два словаря, объединенных вместе:

```python
d1 = {'a': 10, 'b': 20, 'c': 30}
d2 = {'b': 200, 'd': 400}
print(d1)                                       # {'a': 10, 'b': 20, 'c': 30}
print(d2)                                       # {'b': 200, 'd': 400}
d1.update(d2)
print(d1)                                       # {'a': 10, 'b': 200, 'c': 30, 'd': 400}
print(d2)                                       # {'b': 200, 'd': 400}
```

В этом примере ключ `'b'` уже существует `d1`, поэтому его значение обновляется до значения `200` этого ключа из `d2`. 
Однако, нет никакого ключа `'d'` в `d1`, так что пара ключ-значение добавляется из `d2`.

`<obj>` также может быть последовательностью пар ключ-значение, аналогично тому, когда функция `dict()` используется 
для создания словаря. Например, `<obj>` может быть список кортежей:

```python
d1 = {'a': 10, 'b': 20, 'c': 30}
print(d1)                                       # {'a': 10, 'b': 20, 'c': 30}
d1.update([('b', 200), ('d', 400)])
print(d1)                                       # {'a': 10, 'b': 200, 'c': 30, 'd': 400}
```

`<obj>` можеть быть указаны в виде списка ключевых аргументов:

```python
d1 = {'a': 10, 'b': 20, 'c': 30}
d1.update(b = 200, d = 400)
print(d1)                                       # {'a': 10, 'b': 200, 'c': 30, 'd': 400}
```

- **fromkeys(<list>)**

> Метод возвращает словарь с ключами полученными из списка и значениями `None`

```python
lst = ['a', 'b', 'a', 'c', 'c']
print(lst)                                      # ['a', 'b', 'a', 'c', 'c']
d = dict.fromkeys(lst)
print(d)                                        # {'a': None, 'b': None, 'c': None}
lst = list(d)
print(lst)                                      # ['a', 'b', 'c']
```

Пример показывает как можно удалить повторяющиеся значения в списке.

## Заключение

В этом руководстве вы рассмотрели основные свойства **словарей** `Python` и узнали, как обращаться к данным словаря и 
манипулировать ими.

**Списки** и **словари** являются двумя наиболее часто используемыми типами `Python`. Как вы уже видели, они имеют 
несколько сходств, но отличаются по способу доступа к их элементам. Доступ к элементам списков осуществляется по 
числовому индексу в зависимости от порядка, а к элементам словаря - по ключу.

Из-за этого различия списки и словари, как правило, подходят для разных обстоятельств. Теперь у вас должно быть хорошее
чувство, которое, если таковое есть, будет наилучшим для данной ситуации.

























































